input {
  # TCP input for Logstash syslog-style messages
  tcp {
    port => 5000
    codec => json
    tags => ["received"]
  }

  # File input for Honeypot logs
  file {
    path => "/logs/honeypot/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["honeypot"]
    codec => plain {
      charset => "UTF-8"
    }
  }

  # File input for Malware Analysis logs
  file {
    path => "/logs/malware-analysis/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["malware-analysis"]
    codec => plain {
      charset => "UTF-8"
    }
  }

  # File input for Network Traffic Classifier logs
  file {
    path => "/logs/network-traffic/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["network-traffic"]
    codec => plain {
      charset => "UTF-8"
    }
  }

  # File input for WIDS logs
  file {
    path => "/logs/web-ids/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["web-ids"]
    codec => plain {
      charset => "UTF-8"
    }
  }
}

filter {
  # Parse honeypot logs - looking for attack patterns
  if "honeypot" in [tags] {
    mutate {
      add_field => { "[@metadata][index_name]" => "honeypot" }
    }
    
    # Extract honeypot attack data
    grok {
      match => { "message" => "\[%{DATA:attack_type}\] %{IP:attacker_ip} (?<timestamp>%{GREEDYDATA})" }
      add_field => { "log_source" => "honeypot" }
      tag_on_failure => ["honeypot_parse_error"]
    }
    
    # Threat scoring for honeypot
    mutate {
      add_field => { "threat_level" => "medium" }
    }
  }

  # Parse Malware Analysis logs
  if "malware-analysis" in [tags] {
    mutate {
      add_field => { "[@metadata][index_name]" => "malware-analysis" }
    }
    
    grok {
      match => { "message" => "(?<analysis_type>.*?) - (?<file_hash>%{WORD}) - (?<verdict>.*?)( - (?<confidence>%{NUMBER})%)?" }
      add_field => { "log_source" => "malware-analysis" }
      tag_on_failure => ["malware_parse_error"]
    }
    
    # Threat scoring for malware
    if [message] =~ /malware|trojan|virus|worm|ransomware/i {
      mutate {
        add_field => { "threat_level" => "critical" }
      }
    } else {
      mutate {
        add_field => { "threat_level" => "low" }
      }
    }
  }

  # Parse Network Traffic Classifier logs
  if "network-traffic" in [tags] {
    mutate {
      add_field => { "[@metadata][index_name]" => "network-traffic" }
    }
    
    grok {
      match => { "message" => "%{IP:src_ip} -> %{IP:dst_ip}:%{INT:dst_port:int} (?<protocol>.*?) (?<traffic_class>.*?)( - (?<bytes>%{NUMBER:int}))?" }
      add_field => { "log_source" => "network-traffic" }
      tag_on_failure => ["network_parse_error"]
    }
    
    # Threat scoring for network traffic
    if [message] =~ /suspicious|anomaly|attack|exploit/i {
      mutate {
        add_field => { "threat_level" => "high" }
      }
    } else {
      mutate {
        add_field => { "threat_level" => "low" }
      }
    }
  }

  # Parse Web Intrusion Detection logs
  if "web-ids" in [tags] {
    mutate {
      add_field => { "[@metadata][index_name]" => "web-ids" }
    }
    
    grok {
      match => { "message" => "(?<timestamp>%{HTTPDATE}) %{IP:client_ip} (?<method>GET|POST|PUT|DELETE) (?<endpoint>.*?) (?<attack_type>XSS|SQL|CSRF|RFI|LFI|Command Injection)?" }
      add_field => { "log_source" => "web-ids" }
      tag_on_failure => ["web_parse_error"]
    }
    
    # Threat scoring for web attacks
    if [attack_type] {
      mutate {
        add_field => { "threat_level" => "critical" }
      }
    } else {
      mutate {
        add_field => { "threat_level" => "medium" }
      }
    }
  }

  # Add common fields to all events
  mutate {
    add_field => { "[@metadata][timestamp]" => "%{+YYYY.MM.dd}" }
    add_tag => "processed"
  }

  # Convert threat_level to numeric for scoring
  if [threat_level] == "critical" {
    mutate {
      add_field => { "threat_score" => 100 }
    }
  } else if [threat_level] == "high" {
    mutate {
      add_field => { "threat_score" => 75 }
    }
  } else if [threat_level] == "medium" {
    mutate {
      add_field => { "threat_score" => 50 }
    }
  } else {
    mutate {
      add_field => { "threat_score" => 25 }
    }
  }

  # Add timestamp
  date {
    match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z", "ISO8601", "UNIX_MS" ]
    target => "@timestamp"
  }
}

output {
  # Output to Elasticsearch with dynamic index naming
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "security-logs-%{[@metadata][index_name]}-%{[@metadata][timestamp]}"
    document_type => "_doc"
  }

  # Console output for debugging (remove in production)
  # stdout {
  #   codec => rubydebug
  # }

  # File output as backup
  file {
    path => "/logs/processed/output-%{+YYYY-MM-dd}.log"
    codec => json
  }
}
